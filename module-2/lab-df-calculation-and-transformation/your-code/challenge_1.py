# -*- coding: utf-8 -*-
"""challenge-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OvoRQtYA8Tz7TADq5WXGOAN6f-UUxmOG

# Challenge 1

In this challenge you will be working on **pokemons**. You will answer a series of questions in order to practice dataframe calculation, aggregation, and transformation.

![Pokemon](pokemon.jpg)

Follow the instructions below and enter your code.

### Import all required libraries
"""

# import libraries
import numpy as np
import pandas as pd
import re

"""### Import data set

Import data set `Pokemon.csv` from the `your-code` directory of this lab. Read the data into a dataframe called `pokemon`.

*Data set attributed to [Alberto Barradas](https://www.kaggle.com/abcsds/pokemon/)*
"""

# import data set


from google.colab import drive 
drive.mount('/content/gdrive')

temp=pd.read_csv('gdrive/My Drive/Pokemon.csv')

"""### Print first 10 rows of `pokemon`"""

# enter your code here
pokemon.head(10)

"""When you look at a data set, you often wonder what each column means. Some open-source data sets provide descriptions of the data set. In many cases, data descriptions are extremely useful for data analysts to perform work efficiently and successfully.

For the `Pokemon.csv` data set, fortunately, the owner provided descriptions which you can see [here](https://www.kaggle.com/abcsds/pokemon/home). For your convenience, we are including the descriptions below. Read the descriptions and understand what each column means. This knowledge is helpful in your work with the data.

| Column | Description |
| --- | --- |
| # | ID for each pokemon |
| Name | Name of each pokemon |
| Type 1 | Each pokemon has a type, this determines weakness/resistance to attacks |
| Type 2 | Some pokemon are dual type and have 2 |
| Total | A general guide to how strong a pokemon is |
| HP | Hit points, or health, defines how much damage a pokemon can withstand before fainting |
| Attack | The base modifier for normal attacks (eg. Scratch, Punch) |
| Defense | The base damage resistance against normal attacks |
| SP Atk | Special attack, the base modifier for special attacks (e.g. fire blast, bubble beam) |
| SP Def | The base damage resistance against special attacks |
| Speed | Determines which pokemon attacks first each round |
| Generation | Number of generation |
| Legendary | True if Legendary Pokemon False if not |

### Obtain the distinct values across `Type 1` and `Type 2`

Exctract all the values in `Type 1` and `Type 2`. Then create an array containing the distinct values across both fields.
"""

# enter your code here
pd.concat([pokemon['Type 1'], pokemon['Type 2']]).unique()

"""### Cleanup `Name` that contain "Mega"

If you have checked out the pokemon names carefully enough, you should have found there are junk texts in the pokemon names which contain "Mega". We want to clean up the pokemon names. For instance, "VenusaurMega Venusaur" should be "Mega Venusaur", and "CharizardMega Charizard X" should be "Mega Charizard X".
"""

def megaFix(string):
    mega = re.findall('\w+Mega', string)
    if len(mega)>0:
        return string.replace(mega[0], 'Mega')
    return string

pokemon.Name = pokemon.Name.apply(megaFix)
pokemon.Name.head(10)

"""### Create a new column called `A/D Ratio` whose value equals to `Attack` devided by `Defense`

For instance, if a pokemon has the Attack score 49 and Defense score 49, the corresponding `A/D Ratio` is 49/49=1.
"""

# enter your code here
pokemon['A/D Ratio'] = pokemon['Attack'] / pokemon['Defense']
pokemon.head()

"""### Identify the pokemon with the highest `A/D Ratio`"""

# Para sacar algo de 2 barras
pokemon[pokemon['A/D Ratio'] == pokemon['A/D Ratio'].max()]

"""### Identify the pokemon with the lowest A/D Ratio"""

# enter your code here
pokemon[pokemon['A/D Ratio'] == pokemon['A/D Ratio'].min()]

"""### Create a new column called `Combo Type` whose value combines `Type 1` and `Type 2`.

Rules:

* If both `Type 1` and `Type 2` have valid values, the `Combo Type` value should contain both values in the form of `<Type 1> <Type 2>`. For example, if `Type 1` value is `Grass` and `Type 2` value is `Poison`, `Combo Type` will be `Grass-Poison`.

* If `Type 1` has valid value but `Type 2` is not, `Combo Type` will be the same as `Type 1`. For example, if `Type 1` is `Fire` whereas `Type 2` is `NaN`, `Combo Type` will be `Fire`.
"""

# enter your code here

#pokemon['Combo Type'] = pokemon['Type 1'] + "-" + pokemon['Type 2']


pokemon['Combo Type'] = np.where(pokemon['Type 2'].isnull(), pokemon['Type 1'], pokemon['Type 1']+'-'+pokemon['Type 2'])

"""### Identify the pokemons whose `A/D Ratio` are among the top 5"""

# enter your code here

pokemon.sort_values(['A/D Ratio'], ascending=False).head()

"""### For the 5 pokemons printed above, aggregate `Combo Type` and use a list to store the unique values.

Your end product is a list containing the distinct `Combo Type` values of the 5 pokemons with the highest `A/D Ratio`.
"""

# Ojo con el .agg est√° muy bueno para agregar condiciones

top = pokemon.sort_values(['A/D Ratio'], ascending=False).head().agg({'Combo Type':'unique'})['Combo Type'].values.tolist()
top

"""### For each of the `Combo Type` values obtained from the previous question, calculate the mean scores of all numeric fields across all pokemons.

Your output should look like below:

![Aggregate](aggregated-mean.png)
"""

# enter your code here
pokemon.groupby(['Combo Type']).mean().loc[top]

